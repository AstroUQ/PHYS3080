{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PHYS3080 Cosmology Project","text":"<p>Materials for the PHYS3080/7080 Cosmology Project at the University of Queensland.</p>"},{"location":"#host","title":"Host","text":"<p>Tamara Davis,  tamarad@physics.uq.edu.au, Room 6-401</p>"},{"location":"#overview","title":"Overview","text":"<p>Welcome to your next project in Astrophysics III at the University of Queensland. </p> <p>Here you'll be learning how to calculate important aspects of the expansion of the universe, cosmological distances, and cosmological horizons.</p> <p>Start by downloading the pdf with the instructions from the menus on the left. </p> <p>Then look at the example code, available from the menus on the left or download the jupyter notebooks from https://github.com/AstroUQ/PHYS3080/tree/main/cosmo/docs/notebooks  (Click on the file, then right click on \"Raw\" and use \"Save Link As...\" OR if you want to clone the repository use \"git clone https://github.com/AstroUQ/PHYS3080.git \" then navigate into cosmo/docs/notebooks/)</p> <p>Have fun! </p>"},{"location":"notebooks/CosmoIntro/","title":"1. Cosmology Introduction","text":"In\u00a0[1]: Copied! <pre># First let's set up our packages\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom scipy import integrate\n\n# And set some constants\nc = 299792.458 # km/s (speed of light)\n\nH0kmsmpc = 70.  # Hubble constant in km/s/Mpc\nH0s = H0kmsmpc * 3.2408e-20 # H0 in inverse seconds is H0 in km/s/Mpc * (3.2408e-20 Mpc/km)\nH0y = H0s * 3.154e7 * 1.e9 # H0 in inverse Giga years is H0 in inverse seconds * (3.154e7 seconds/year) * (1e9 years / Giga year)\nprint('Hubble time = ',1/H0y,'Gyr')\n\n# Let's format that to a more appropriate number of significant figures.  \n# The first % means put the variable here.  The .2f means make it a float with 2 decimal places.\nprint('Hubble time = %.2f Gyr'%(1/H0y))\n</pre> # First let's set up our packages import numpy as np from matplotlib import pyplot as plt from scipy import integrate  # And set some constants c = 299792.458 # km/s (speed of light)  H0kmsmpc = 70.  # Hubble constant in km/s/Mpc H0s = H0kmsmpc * 3.2408e-20 # H0 in inverse seconds is H0 in km/s/Mpc * (3.2408e-20 Mpc/km) H0y = H0s * 3.154e7 * 1.e9 # H0 in inverse Giga years is H0 in inverse seconds * (3.154e7 seconds/year) * (1e9 years / Giga year) print('Hubble time = ',1/H0y,'Gyr')  # Let's format that to a more appropriate number of significant figures.   # The first % means put the variable here.  The .2f means make it a float with 2 decimal places. print('Hubble time = %.2f Gyr'%(1/H0y)) <pre>Hubble time =  13.976165695516954 Gyr\nHubble time = 13.98 Gyr\n</pre> In\u00a0[2]: Copied! <pre># Write a function for the integrand, i.e. $1/\\dot{a}$ (adot inverse)\n# I'm going to keep the constant H_0 outside the integral and add it later.\ndef adotinv_flatmatter(a):\n    return np.sqrt(a) \n\n# First note some weird python notation, if you say \"x, y = 1, 2\" it's the same as saying \"x=1\" and \"y=2\".\n\n# Now integrate that equation from scalefactor 0 to 1 (as an example) which will give the age of the universe today (because we define a so that a=1 today):\nage_Hubble, uncert = integrate.quad(adotinv_flatmatter,0,1) \n# This returns age in Hubble times, and the uncertainty in the numerical integral\n\n# Convert that to billions of years\nage_Gyr = age_Hubble/H0y # Age in Gyr\n\nprint('Age of the universe in Hubble times = %.3f which is %.2f Gyr'%(age_Hubble,age_Gyr))\nprint('Does this match the analytic prediction of 2/3 Hubble times?  Yes!')\nprint('')\nprint('Uncertainty on the numerical integral is ', uncert, 'so should be negligible.') # It's good to check this to check that the integral has succeeded.\n\n# Note, to get just the age without the uncertainty you can use [0] to get the first element that's returned,\n# and then you can also divide by H0y immediately to get the age in one step\nage_Gyr_easier = integrate.quad(adotinv_flatmatter,0,1)[0] / H0y \n\nprint('Just checking that the one-step age calculation (%.2f Gyr) matches the two step one (%.2f Gyr).'%(age_Gyr_easier,age_Gyr))\n</pre> # Write a function for the integrand, i.e. $1/\\dot{a}$ (adot inverse) # I'm going to keep the constant H_0 outside the integral and add it later. def adotinv_flatmatter(a):     return np.sqrt(a)   # First note some weird python notation, if you say \"x, y = 1, 2\" it's the same as saying \"x=1\" and \"y=2\".  # Now integrate that equation from scalefactor 0 to 1 (as an example) which will give the age of the universe today (because we define a so that a=1 today): age_Hubble, uncert = integrate.quad(adotinv_flatmatter,0,1)  # This returns age in Hubble times, and the uncertainty in the numerical integral  # Convert that to billions of years age_Gyr = age_Hubble/H0y # Age in Gyr  print('Age of the universe in Hubble times = %.3f which is %.2f Gyr'%(age_Hubble,age_Gyr)) print('Does this match the analytic prediction of 2/3 Hubble times?  Yes!') print('') print('Uncertainty on the numerical integral is ', uncert, 'so should be negligible.') # It's good to check this to check that the integral has succeeded.  # Note, to get just the age without the uncertainty you can use [0] to get the first element that's returned, # and then you can also divide by H0y immediately to get the age in one step age_Gyr_easier = integrate.quad(adotinv_flatmatter,0,1)[0] / H0y   print('Just checking that the one-step age calculation (%.2f Gyr) matches the two step one (%.2f Gyr).'%(age_Gyr_easier,age_Gyr))   <pre>Age of the universe in Hubble times = 0.667 which is 9.32 Gyr\nDoes this match the analytic prediction of 2/3 Hubble times?  Yes!\n\nUncertainty on the numerical integral is  7.401486830834379e-16 so should be negligible.\nJust checking that the one-step age calculation (9.32 Gyr) matches the two step one (9.32 Gyr).\n</pre> In\u00a0[3]: Copied! <pre># Insert your code here\nage_half_Gyr = 'Your code'\nage_double_Gyr = 'Your code'\n\n# Remember to write print statements to see the answers.\n</pre> # Insert your code here age_half_Gyr = 'Your code' age_double_Gyr = 'Your code'  # Remember to write print statements to see the answers.     In\u00a0[4]: Copied! <pre># Start by making an array of scalefactors\nastart = 0.0\nastop = 2.1\nastep = 0.1 # Make this finer to make the plot smoother\na_arr = np.arange(astart,astop,astep)\nprint('a_arr=',a_arr)\n</pre> # Start by making an array of scalefactors astart = 0.0 astop = 2.1 astep = 0.1 # Make this finer to make the plot smoother a_arr = np.arange(astart,astop,astep) print('a_arr=',a_arr) <pre>a_arr= [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.  1.1 1.2 1.3 1.4 1.5 1.6 1.7\n 1.8 1.9 2. ]\n</pre> In\u00a0[5]: Copied! <pre># First set up an array of times (initially all set to zero) into which we'll put our calculated times\nt_Gyr = np.zeros(len(a_arr))  # len(a_arr) gives the length of the a_arr \n\n# Make a loop and do that integral for every final value of a (starting at a=0 every time)\nfor i,a_end in enumerate(a_arr): # enumerate adds an index to each value\n    t_Hubble,uncert = integrate.quad(adotinv_flatmatter,0,a_end)\n    t_Gyr[i] = t_Hubble/H0y\n\n# It's good practise to compare it to the analytic calculation when available\nt_analytic_Gyr = 'Add the analytic equation from above here (and uncomment the plotting line for it below)'\n    \nplt.plot(t_Gyr,a_arr)\nplt.plot(age_Gyr, 1.0,'o') # Put a dot at the current time\n#plt.plot(t_analytic_Gyr, a_arr,':',color='red')\nplt.xlabel('Time (Gyr)')\nplt.ylabel('Scalefactor')\nplt.show()\n</pre> # First set up an array of times (initially all set to zero) into which we'll put our calculated times t_Gyr = np.zeros(len(a_arr))  # len(a_arr) gives the length of the a_arr   # Make a loop and do that integral for every final value of a (starting at a=0 every time) for i,a_end in enumerate(a_arr): # enumerate adds an index to each value     t_Hubble,uncert = integrate.quad(adotinv_flatmatter,0,a_end)     t_Gyr[i] = t_Hubble/H0y  # It's good practise to compare it to the analytic calculation when available t_analytic_Gyr = 'Add the analytic equation from above here (and uncomment the plotting line for it below)'      plt.plot(t_Gyr,a_arr) plt.plot(age_Gyr, 1.0,'o') # Put a dot at the current time #plt.plot(t_analytic_Gyr, a_arr,':',color='red') plt.xlabel('Time (Gyr)') plt.ylabel('Scalefactor') plt.show() In\u00a0[6]: Copied! <pre># You might be interested to know that python has some shortcuts.  The whole step above (except the plotting) can be done in one line:\nt2_Gyr = np.array([integrate.quad(adotinv_flatmatter, 0, a_end)[0] for a_end in a_arr])/H0y\n\nplt.plot(t_Gyr,a_arr,label='longhand') # Plot original from above\nplt.plot(t2_Gyr,a_arr,'--',color='black',label='shortcut') # Plot new one-line calculation to show it is the same\n#plt.plot(t_analytic_Gyr, a_arr,':',color='red',label='analytic')\nplt.plot(age_Gyr, 1.0,'o',label='today') # Put a dot at the current time\nplt.xlabel('Time (Gyr)')\nplt.ylabel('Scalefactor')\nplt.legend(frameon=False)\nplt.show()\n</pre> # You might be interested to know that python has some shortcuts.  The whole step above (except the plotting) can be done in one line: t2_Gyr = np.array([integrate.quad(adotinv_flatmatter, 0, a_end)[0] for a_end in a_arr])/H0y  plt.plot(t_Gyr,a_arr,label='longhand') # Plot original from above plt.plot(t2_Gyr,a_arr,'--',color='black',label='shortcut') # Plot new one-line calculation to show it is the same #plt.plot(t_analytic_Gyr, a_arr,':',color='red',label='analytic') plt.plot(age_Gyr, 1.0,'o',label='today') # Put a dot at the current time plt.xlabel('Time (Gyr)') plt.ylabel('Scalefactor') plt.legend(frameon=False) plt.show() In\u00a0[7]: Copied! <pre>t_lookback_Gyr = 'Your code here'\n\n# Uncomment the commands below to plot your result\n#plt.plot(t_lookback_Gyr,a_arr) \n#plt.axvline(x=0,linestyle=':') # Plot some crosshairs \n#plt.axhline(y=1,linestyle=':')\n#plt.plot(0.0, 1.0,'o') # Put a dot at the current time\n#plt.xlabel('Lookback time (Gyr)')\n#plt.ylabel('Scalefactor')\n#plt.show()\n</pre> t_lookback_Gyr = 'Your code here'  # Uncomment the commands below to plot your result #plt.plot(t_lookback_Gyr,a_arr)  #plt.axvline(x=0,linestyle=':') # Plot some crosshairs  #plt.axhline(y=1,linestyle=':') #plt.plot(0.0, 1.0,'o') # Put a dot at the current time #plt.xlabel('Lookback time (Gyr)') #plt.ylabel('Scalefactor') #plt.show() In\u00a0[8]: Copied! <pre># First calculate the index corresponding to a=1.0.  (Find when |a-1.0| is minimum.  You could also do this by just redoing the integral from 0&lt;a&lt;1, but the way I've set it up above we know we have an a=1 in the array, so we can just find what we've already calculated.)\nindex_today = np.argmin(np.abs(a_arr - 1.0))\n\n# Then find the time corresponding to that index  (note you do NOT have to do the integral again)\nage_today = 'Your code here' \n\nt2_lookback_Gyr = 'Your code here'\n\n# Uncomment the commands below to plot your result\n#plt.plot(t2_lookback_Gyr,a_arr) \n#plt.axvline(x=0,linestyle=':') # Plot some crosshairs \n#plt.axhline(y=1,linestyle=':')\n#plt.plot(0.0, 1.0,'o') # Put a dot at the current time\n#plt.xlabel('Lookback time (Gyr)')\n#plt.ylabel('Scalefactor')\n#plt.show()\n</pre> # First calculate the index corresponding to a=1.0.  (Find when |a-1.0| is minimum.  You could also do this by just redoing the integral from 0 In\u00a0[9]: Copied! <pre># First write a function that takes as input a, Omega_M (om), and Omega_Lambda (ol) and outputs 1/adot\ndef adotinv(a,om,ol):\n    adot='Your code here (Remember to keep H_0 separate i.e. just calculate adot/H_0.)'\n    return 1.0/adot\n</pre> # First write a function that takes as input a, Omega_M (om), and Omega_Lambda (ol) and outputs 1/adot def adotinv(a,om,ol):     adot='Your code here (Remember to keep H_0 separate i.e. just calculate adot/H_0.)'     return 1.0/adot In\u00a0[1]: Copied! <pre># Calculate for the universe we think we live in, with approximately matter density 0.3 and cosmological constant 0.7\nom = 0.1\nol = 1.3\n\n# Note that when you integrate something with more than one argument you pass it with args=(arg1,arg2) in the integrate function\n# e.g. \"integrate.quad(adotinv, lower_limit, uper_limit, args=(om,ol))\"\"\nt_lookback_Gyr = 'Your code here'\n\n# Uncomment these commands to plot this new model (note I've added a label that can be used in the legend)\n#plt.plot(t_lookback_Gyr,a_arr,label='$(\\Omega_M,\\Omega_\\Lambda)$=(%.2f,%.2f)'%(om,ol)) \n#plt.axvline(x=0,linestyle=':') # Plot some crosshairs \n#plt.axhline(y=1,linestyle=':')\n#plt.xlabel('Lookback time (Gyr)')\n#plt.ylabel('Scalefactor')\n#plt.legend(loc='lower right',frameon=False)\n#plt.show()\n</pre> # Calculate for the universe we think we live in, with approximately matter density 0.3 and cosmological constant 0.7 om = 0.1 ol = 1.3  # Note that when you integrate something with more than one argument you pass it with args=(arg1,arg2) in the integrate function # e.g. \"integrate.quad(adotinv, lower_limit, uper_limit, args=(om,ol))\"\" t_lookback_Gyr = 'Your code here'  # Uncomment these commands to plot this new model (note I've added a label that can be used in the legend) #plt.plot(t_lookback_Gyr,a_arr,label='$(\\Omega_M,\\Omega_\\Lambda)$=(%.2f,%.2f)'%(om,ol))  #plt.axvline(x=0,linestyle=':') # Plot some crosshairs  #plt.axhline(y=1,linestyle=':') #plt.xlabel('Lookback time (Gyr)') #plt.ylabel('Scalefactor') #plt.legend(loc='lower right',frameon=False) #plt.show() In\u00a0[15]: Copied! <pre>om_arr = np.arange(0.1,2.1,0.4)\nol = 0.7\n\nfor om in om_arr:\n    t_lookback_Gyr = 'Your code here'\n#    plt.plot(t_lookback_Gyr,a_arr,label='$(\\Omega_M,\\Omega_\\Lambda)$=(%.1f,%.1f)'%(om,ol))\n    \n#plt.axvline(x=0,linestyle=':') # Plot some crosshairs \n#plt.axhline(y=1,linestyle=':')\n#plt.xlabel('Lookback time (Gyr)')\n#plt.ylabel('Scalefactor')\n#plt.legend(loc='lower right',frameon=False)\n#plt.show()\n</pre> om_arr = np.arange(0.1,2.1,0.4) ol = 0.7  for om in om_arr:     t_lookback_Gyr = 'Your code here' #    plt.plot(t_lookback_Gyr,a_arr,label='$(\\Omega_M,\\Omega_\\Lambda)$=(%.1f,%.1f)'%(om,ol))      #plt.axvline(x=0,linestyle=':') # Plot some crosshairs  #plt.axhline(y=1,linestyle=':') #plt.xlabel('Lookback time (Gyr)') #plt.ylabel('Scalefactor') #plt.legend(loc='lower right',frameon=False) #plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/CosmoIntro/#1-cosmology-introduction","title":"1. Cosmology Introduction\u00b6","text":"<p>This notebook will step you through some of the simple steps needed to calculate and plot the expansion of the universe as a function of time.</p> <p>You can download this as a Jupyter Notebook from https://github.com/AstroUQ/PHYS3080/tree/main/cosmo/docs/notebooks (click on the file, when it opens right click on \"Raw\" then \"Save Link As...\").</p>"},{"location":"notebooks/CosmoIntro/#11-how-old-is-the-universe","title":"1.1 How old is the universe?\u00b6","text":"<p>In order to calculate how the expansion of the universe changes with time one needs to integrate over the changing expansion history.</p> <p>We define an overdot to mean differentiation with respect to time: $\\dot{a}=da/dt$.  Which means that,</p> \\begin{equation} \\int_0^t dt = \\int_0^a \\frac{da}{\\dot{a}}. \\end{equation}<p>That is convenient because we know an equation for $\\dot{a}$ as a function of $a$, Friedmann's equation!  Let's start with a simple flat matter-dominated universe, for which Friedmann's equation gives,</p> $$ \\dot{a} = H_0 a^{-1/2}. $$<p>It's easy to show analytically that in this flat matter dominated case the integral above for scalefactor as a function of time becomes,</p> $$ t = \\frac{2}{3H_0}a^{3/2}. $$<p>For more complex models there's no simple analytic solution, so we will want to do that numerically.  Let's see how to do it numerically in this simple case first.</p>"},{"location":"notebooks/CosmoIntro/#111-for-you","title":"1.1.1 For you!\u00b6","text":"<p>Now you can have a go and change the limits of the integral so you can measure different times. For example how old was the universe when it was half its current size? How long will it take to expand from now to twice it's current size?</p>"},{"location":"notebooks/CosmoIntro/#12-scalefactor-vs-time","title":"1.2 Scalefactor vs time\u00b6","text":"<p>Now let's try to calculate the time not just at one value of scalefactor, but a whole array.  We can then make a plot of scalefactor vs time.</p>"},{"location":"notebooks/CosmoIntro/#121-lookback-time-for-you","title":"1.2.1 Lookback time - for you\u00b6","text":"<p>It can be useful to normalise time to be 0 at the present day, then everything in the past is a negative time relative to today.   You can do that by setting the lower limit of the integral to a=1.0, then all times are measured relative to the present time.</p>"},{"location":"notebooks/CosmoIntro/#122-another-way-to-calculate-lookback-time","title":"1.2.2 Another way to calculate lookback time\u00b6","text":"<p>If you don't want to do the integral again (integrals can be computationally expensive) you can find the time closest to the present day by finding the index closest to a=1.0, and subtracting that time from all the times in the array.  Give that a go...</p>"},{"location":"notebooks/CosmoIntro/#13-more-complex-models","title":"1.3 More complex models\u00b6","text":"<p>In general Friedmann's equation gives,</p> $$ H(a)^2\\equiv \\frac{\\dot{a}^2}{a^2} = H_0^2 \\sum_i \\Omega_i a^{-3(1+w_i)}, $$<p>where the $\\Omega_i$ correspond to different components of the universe (like matter) and $w_i$ are the corresponding equations of state.</p> <p>Writing that out more fully we should consider  matter density $\\Omega_M$ (includes normal and dark matter and $w_M=0$);  curvature $\\Omega_K=1.0-\\Omega_M-\\Omega_\\Lambda$ ($w_K=-1/3$); and cosmological constant $\\Omega_\\Lambda$ ($w_\\Lambda=-1$).</p> <p>Later we'll consider a more general dark energy $\\Omega_x$ ($w_x=$ unknown), and also add radiation density $\\Omega_R$ ($w_R=1/3$).</p> <p>Expanding the sum above for a universe with matter and a cosmological constant we get, $$ \\frac{\\dot{a}}{a} = H_0 \\left[\\Omega_M a^{-3}+\\Omega_K a^{-2} + \\Omega_\\Lambda \\right]^{1/2}. $$</p> <p>Now let's integrate this more complex function.</p>"},{"location":"notebooks/CosmoIntro/#131-your-turn-build-your-own-universes","title":"1.3.1 Your turn!  Build your own universes!\u00b6","text":"<p>Change the input matter density and cosmological constant.</p> <ul> <li>Can you make a universe that recollapses?</li> <li>What about one that has a bounce instead of a Big Bang in the past?</li> <li>What about one that always decelerates but never recollapses?</li> <li>Can you find any really weird behaviour?  If so can you explain it?</li> </ul>"},{"location":"notebooks/CosmoIntro/#132-plot-many-universes-on-the-same-plot","title":"1.3.2 Plot many universes on the same plot\u00b6","text":"<p>Now you can take that all and put it in a loop if you like, to compare different universes:</p>"},{"location":"notebooks/CosmoIntro/#133-your-turn-add-even-more-complex-models","title":"1.3.3 Your turn!  Add even more complex models...\u00b6","text":"<p>Congratulations, you can now calculate how the expansion of the universe proceeds with time!</p> <p>From here you can play with the input parameters.  What happens when you:</p> <ul> <li>fix the cosmological constant and change matter density?</li> <li>add radiation?</li> <li>add dark energy with a different equation of state?</li> </ul> <p>You might find it useful to make a more general <code>adotinv</code> function that takes into account all these possibilities.</p>"},{"location":"notebooks/Distances/","title":"2. Distances in cosmology","text":"In\u00a0[15]: Copied! <pre># First let's set up our packages\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom scipy import integrate\n\n# And set some constants\nc = 299792.458 # km/s (speed of light)\n\nH0kmsmpc = 70.  # Hubble constant in km/s/Mpc\ncH0mpc = c/H0kmsmpc   # c/H0 in Mpc  (the km/s cancel out in the numerator and denominator)\ncH0Glyr = cH0mpc * 3.262 / 1000 #c/H0 in billions of light years.  There are 3.262 light year / parsec\n</pre> # First let's set up our packages import numpy as np from matplotlib import pyplot as plt from scipy import integrate  # And set some constants c = 299792.458 # km/s (speed of light)  H0kmsmpc = 70.  # Hubble constant in km/s/Mpc cH0mpc = c/H0kmsmpc   # c/H0 in Mpc  (the km/s cancel out in the numerator and denominator) cH0Glyr = cH0mpc * 3.262 / 1000 #c/H0 in billions of light years.  There are 3.262 light year / parsec In\u00a0[18]: Copied! <pre># Write a function for the integrand, i.e. $1/E(z)$,\ndef Ezinv(z, om, ol):\n    ok = 1.0-om-ol\n    Ez = np.sqrt(0.0) # Put your code here!  This is not right until you change it.\n    return 1.0/Ez\n\n# Choose the redshift (e.g. z=0.3)\nz=0.3\n\n# Choose a cosmology\nom, ol = 0.3, 0.7\n\n# Calcuate the integral (just the int_0^z(dz/E(z)) part, which givers xx=R0*X/(c/H_0)):\nxx = integrate.quad(Ezinv,0,z,args=(om,ol))[0] \n\n# Sub in the required constants to get the comoving distance R_0*X\nR0X = xx*cH0Glyr # Distance in Glyr\n\nprint('Comoving distance to a galaxy at z=%.3f is %.2f Glyr (this is not right until you have put the correct equation for Ez above)'%(z,R0X))\n</pre> # Write a function for the integrand, i.e. $1/E(z)$, def Ezinv(z, om, ol):     ok = 1.0-om-ol     Ez = np.sqrt(0.0) # Put your code here!  This is not right until you change it.     return 1.0/Ez  # Choose the redshift (e.g. z=0.3) z=0.3  # Choose a cosmology om, ol = 0.3, 0.7  # Calcuate the integral (just the int_0^z(dz/E(z)) part, which givers xx=R0*X/(c/H_0)): xx = integrate.quad(Ezinv,0,z,args=(om,ol))[0]   # Sub in the required constants to get the comoving distance R_0*X R0X = xx*cH0Glyr # Distance in Glyr  print('Comoving distance to a galaxy at z=%.3f is %.2f Glyr (this is not right until you have put the correct equation for Ez above)'%(z,R0X)) <pre>Comoving distance to a galaxy at z=0.300 is 0.00 Glyr (this is not right until you have put the correct equation for Ez above)\n</pre> In\u00a0[13]: Copied! <pre># Insert your code here\ndistance_half_size = 'your code here'\ndistance_at_emission = 'your code here'\n\n# Remember to write print statements to see the answers. \n#print('Distance to a galaxy at z=%.3f when a=0.5 is %.2f Glyr'%distance_half_size)\n#print('Distance to a galaxy at z=%.3f when the light we see was emitted is %.2f Glyr'%distance_at_emission)\n</pre> # Insert your code here distance_half_size = 'your code here' distance_at_emission = 'your code here'  # Remember to write print statements to see the answers.  #print('Distance to a galaxy at z=%.3f when a=0.5 is %.2f Glyr'%distance_half_size) #print('Distance to a galaxy at z=%.3f when the light we see was emitted is %.2f Glyr'%distance_at_emission)  In\u00a0[31]: Copied! <pre># Start by making an array of redshifts\nzstart = 0.0\nzstop = 4.1\nzstep = 0.1 # Make this finer to make the plot smoother\nzarr = np.arange(zstart,zstop,zstep)\nprint('zarr=',zarr)\n\n# Now add your code to calculate distance vs redshift and then plot it.  \nxarr = np.zeros(len(zarr))\nfor i, z in enumerate(zarr):\n    xarr[i] = 0.0 #'Your code here'\n    \n# Sub in the required constants to get the comoving distance R_0*X\n#R0X = xarr*cH0Glyr # Distance in Glyr\n\n#plt.plot(zarr,R0X)\n#plt.xlabel('redshift')\n#plt.ylabel('$R_0\\chi$ (Glyr)')\n#plt.show()\n</pre> # Start by making an array of redshifts zstart = 0.0 zstop = 4.1 zstep = 0.1 # Make this finer to make the plot smoother zarr = np.arange(zstart,zstop,zstep) print('zarr=',zarr)  # Now add your code to calculate distance vs redshift and then plot it.   xarr = np.zeros(len(zarr)) for i, z in enumerate(zarr):     xarr[i] = 0.0 #'Your code here'      # Sub in the required constants to get the comoving distance R_0*X #R0X = xarr*cH0Glyr # Distance in Glyr  #plt.plot(zarr,R0X) #plt.xlabel('redshift') #plt.ylabel('$R_0\\chi$ (Glyr)') #plt.show()  <pre>zarr= [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.  1.1 1.2 1.3 1.4 1.5 1.6 1.7\n 1.8 1.9 2.  2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.  3.1 3.2 3.3 3.4 3.5\n 3.6 3.7 3.8 3.9 4. ]\n</pre> In\u00a0[32]: Copied! <pre># You may find this function useful to calculate the perpendicular comoving distance R0*Sk(X)\n    # Corrects the comoving distance, xx, for curvature, ok.\n    # Result is perpendicular comoving distance / (c/H0)  \n    # i.e. it's the distance to use in angular diameter and luminosity distance\ndef Sk(xx, ok):\n    if ok &lt; 0.0:\n        dk = np.sin(np.sqrt(-ok)*xx)/np.sqrt(-ok)\n    elif ok &gt; 0.0:\n        dk = np.sinh(np.sqrt(ok)*xx)/np.sqrt(ok)\n    else:\n        dk = xx\n    return dk\n# This returns a value for R_0S_k(\\chi) that you multiply by c/H_0 to give it units.\n</pre> # You may find this function useful to calculate the perpendicular comoving distance R0*Sk(X)     # Corrects the comoving distance, xx, for curvature, ok.     # Result is perpendicular comoving distance / (c/H0)       # i.e. it's the distance to use in angular diameter and luminosity distance def Sk(xx, ok):     if ok &lt; 0.0:         dk = np.sin(np.sqrt(-ok)*xx)/np.sqrt(-ok)     elif ok &gt; 0.0:         dk = np.sinh(np.sqrt(ok)*xx)/np.sqrt(ok)     else:         dk = xx     return dk # This returns a value for R_0S_k(\\chi) that you multiply by c/H_0 to give it units. In\u00a0[34]: Copied! <pre>ok = 1.0-om-ol\nDD = R0X                          # Proper distance\nDL = Sk(xarr,ok)*(1+zarr)*cH0Glyr # Luminosity distance\nDA = 'Your code here'             # Angular diameter distance\n\n#plt.plot(zarr,DD,label='Proper Distance')\n#plt.plot(zarr,DL,label='Luminosity Distance')\n##plt.plot(zarr,DA,label='Angular Diameter Distance')\n#plt.legend()\n#plt.xlabel('redshift')\n#plt.ylabel('$Distances$ (Glyr)')\n#plt.show()\n</pre> ok = 1.0-om-ol DD = R0X                          # Proper distance DL = Sk(xarr,ok)*(1+zarr)*cH0Glyr # Luminosity distance DA = 'Your code here'             # Angular diameter distance  #plt.plot(zarr,DD,label='Proper Distance') #plt.plot(zarr,DL,label='Luminosity Distance') ##plt.plot(zarr,DA,label='Angular Diameter Distance') #plt.legend() #plt.xlabel('redshift') #plt.ylabel('$Distances$ (Glyr)') #plt.show()"},{"location":"notebooks/Distances/#2-distances-in-cosmology","title":"2. Distances in cosmology\u00b6","text":"<p>This notebook will step you through calculating distances in cosmology.</p>"},{"location":"notebooks/Distances/#how-far-is-a-galaxy-at-redshift-z","title":"How far is a galaxy at redshift z?\u00b6","text":"<p>To calculate how far a galaxy is if it has redshift z we need to integrate over the path of the photon since the time of emission to the time of observation.</p> <p>Again we can start with Friedmann's equation,</p> \\begin{equation} H^2 = H_0^2\\sum \\Omega_x a^{-3(1+w_x)}, \\end{equation}<p>and recall that the definition of redshift is that a=(1+z)^{-1}, therefore,</p> \\begin{equation} H^2 = H_0^2\\sum \\Omega_x (1+z)^{3(1+w_x)}, \\end{equation}<p>(notice the change of sign in the exponent).</p> <p>Since $ds=0$ for a photon the metric gives $cdt = Rd\\chi$.  Using $R=R_0a$ that can be rearranged to the equation for the comoving distance,</p> \\begin{equation} R_0\\chi = c\\int \\frac{dt}{a} = c\\int \\frac{dt}{da} \\frac{da}{a} = c\\int \\frac{da}{\\dot{a}a} \\end{equation}<p>Differentiating $a$ with respect to $z$ gives $da = -(1+z)^{-2} dz$, and putting all of that together gives the equation for comoving distance as a function of redshift,</p> \\begin{eqnarray} R_0\\chi &amp;=&amp; c\\int_0^z \\frac{dz}{H(z)}, \\\\                          &amp;=&amp; \\frac{c}{H_0}\\int_0^z \\frac{dz}{E(z)}, \\end{eqnarray}<p>where $E(z)\\equiv H(z)/H_0$.  Written out longhand that is  \\begin{equation} E(z)= \\left(\\Omega_M (1+z)^3+\\Omega_K (1+z)^2+\\Omega_\\Lambda\\right)^{1/2}.\\end{equation} (Or some more complex model!)  Usually we set $\\Omega_R=0$ otherwise there would also be a $\\Omega_R (1+z)^4$ term (the actual radiation density is about $\\Omega_R\\sim5\\times 10^{-5}$), but IMPORTANT! you cannot set $\\Omega_K=0$ in general, because it is only zero if all the other densities add up to 1.</p>"},{"location":"notebooks/Distances/#21-write-some-code-to-calculate-the-distance-to-a-galaxy-at-redshift-z","title":"2.1 Write some code to calculate the distance to a galaxy at redshift z\u00b6","text":"<p>Define the function you need to integrate, and integrate it for a single value of z that you choose.</p>"},{"location":"notebooks/Distances/#22-how-far-is-that-galaxy-at-different-times","title":"2.2 How far is that galaxy at different times?\u00b6","text":"<p>The comoving distance is normalised such that it is the distance at the present day.  How far was that galaxy (the one we currently observe at redshift z) at different times? To get the distance at a different time, just multiply the comoving distance by the scalefactor at that time.  \\begin{equation} D(t(z),\\chi(z)) = a(t) R_0\\chi(z) \\end{equation}</p> <p>Example: take a galaxy at z=0.3.</p> <ul> <li>What was its distance from us when the universe was half its current size?</li> <li>How far was it at the time the light we're seeing was emitted?  Recall that the scalefactor at the time of emisison can be derived from its redshift, i.e. a=1/(1+z).</li> </ul>"},{"location":"notebooks/Distances/#23-turn-that-into-a-plot-of-distance-vs-redshift","title":"2.3 Turn that into a plot of distance vs redshift\u00b6","text":"<p>Make an array of redshifts and make a loop to calculate the distance at each of those redshifts.  Then plot distance vs redshift.</p> <ul> <li>Make one plot that is current distance ($R_0\\chi$) vs redshift.</li> <li>Make another showing distance at the time of emission ($aR_0\\chi$) vs redshift.</li> </ul> <p>Do you notice anything interesting about the behaviour of these two different distances?</p>"},{"location":"notebooks/Distances/#24-luminosity-distance-and-angular-diameter-distance","title":"2.4 Luminosity distance and Angular diameter distance\u00b6","text":"<p>Luminosity distance ($D_L$) and angular diameter distance ($D_A$) are given by, \\begin{equation} D_L = R S_k(\\chi) (1+z) \\end{equation} \\begin{equation} D_A = R S_k(\\chi) / (1+z) \\end{equation}</p> <p>Where $S_k(\\chi) = \\sin(\\chi),\\chi,\\sinh(\\chi)$ for positive, flat, and negative curvatures respectively, i.e. for $\\Omega_K&lt;0$, $\\Omega_K=0$, and $\\Omega_K&gt;0$ respectively. (Yes, $\\Omega_K&lt;0$ is positive curvature!)</p>"},{"location":"notebooks/Distances/#hint-how-to-calculate-s_kchi","title":"Hint!  How to calculate $S_k(\\chi)$\u00b6","text":"<p>Note that if you've kept the constants out of your definition of Ez then, xx $\\equiv R_0\\chi/(c/H_0)$.  It is handy to know that, \\begin{equation}  \\frac{c}{R_0H_0}=\\sqrt{|\\Omega_K|}\\end{equation} so to just get $\\chi$ you can use xx multiplied by $\\sqrt{|\\Omega_K|}$. Then to get $R_0 S_k(\\chi)/(c/H_0)$ divide the whole thing by $\\sqrt{|\\Omega_K|}$.</p>"},{"location":"notebooks/Distances/#calculate-d_lz-and-d_az","title":"Calculate $D_L(z)$ and $D_A(z)$\u00b6","text":"<p>Plot the present day values ($R=R_0$) of luminosity distance and angular diameter distance as a function of redshift. Do you notice anything interesting about the angular diameter distance at high-redshift?</p>"},{"location":"notebooks/Fit_Models/","title":"3. Fitting models to data","text":"In\u00a0[1]: Copied! <pre># First let's set up our packages\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom scipy import integrate\n\n# And set some constants\nc = 299792.458 # km/s (speed of light)\nH0kmsmpc = 70.  # Hubble constant in km/s/Mpc\nH0s = H0kmsmpc * 3.2408e-20 # H0 in inverse seconds is H0 in km/s/Mpc * (3.2408e-20 Mpc/km)\n\n# Write a function for the integrand, i.e. $1/E(z)$,\ndef ezinv(z,om=0.3,ol=0.7,w0=-1.0,wa=0.0,orr=0.0):\n    ok = 1.-om-ol-orr\n    ez = 1.0  ############# REPLACE THIS WITH YOUR CODE ################\n    return 1./ez\n\n# The curvature correction function\ndef Sk(xx, ok):\n    if ok &lt; 0.0:\n        dk = np.sin(np.sqrt(-ok)*xx)/np.sqrt(-ok)\n    elif ok &gt; 0.0:\n        dk = np.sinh(np.sqrt(ok)*xx)/np.sqrt(ok)\n    else:\n        dk = xx\n    return dk\n\n# The distance modulus\ndef dist_mod(zs,om=0.3,ol=0.7,w0=-1.0,wa=0.0,orr=0.0):\n\"\"\" Calculate the distance modulus, correcting for curvature\"\"\"\n    ok = 1.0 - om - ol\n    xx = np.array([integrate.quad(ezinv, 0, z, args=(om, ol, w0, wa, orr))[0] for z in zs])\n    D = Sk(xx, ok)\n    lum_dist = D * (1 + zs) \n    dist_mod = 5 * np.log10(lum_dist) # Distance modulus\n    # Add an arbitrary constant that's approximately the log of c on Hubble constant minus absolute magnitude of -19.5\n    dist_mod = dist_mod + np.log(c/H0kmsmpc)-(-19.5)  # You can actually skip this step and it won't make a difference to our fitting\n    return dist_mod\n</pre> # First let's set up our packages import numpy as np from matplotlib import pyplot as plt from scipy import integrate  # And set some constants c = 299792.458 # km/s (speed of light) H0kmsmpc = 70.  # Hubble constant in km/s/Mpc H0s = H0kmsmpc * 3.2408e-20 # H0 in inverse seconds is H0 in km/s/Mpc * (3.2408e-20 Mpc/km)  # Write a function for the integrand, i.e. $1/E(z)$, def ezinv(z,om=0.3,ol=0.7,w0=-1.0,wa=0.0,orr=0.0):     ok = 1.-om-ol-orr     ez = 1.0  ############# REPLACE THIS WITH YOUR CODE ################     return 1./ez  # The curvature correction function def Sk(xx, ok):     if ok &lt; 0.0:         dk = np.sin(np.sqrt(-ok)*xx)/np.sqrt(-ok)     elif ok &gt; 0.0:         dk = np.sinh(np.sqrt(ok)*xx)/np.sqrt(ok)     else:         dk = xx     return dk  # The distance modulus def dist_mod(zs,om=0.3,ol=0.7,w0=-1.0,wa=0.0,orr=0.0):     \"\"\" Calculate the distance modulus, correcting for curvature\"\"\"     ok = 1.0 - om - ol     xx = np.array([integrate.quad(ezinv, 0, z, args=(om, ol, w0, wa, orr))[0] for z in zs])     D = Sk(xx, ok)     lum_dist = D * (1 + zs)      dist_mod = 5 * np.log10(lum_dist) # Distance modulus     # Add an arbitrary constant that's approximately the log of c on Hubble constant minus absolute magnitude of -19.5     dist_mod = dist_mod + np.log(c/H0kmsmpc)-(-19.5)  # You can actually skip this step and it won't make a difference to our fitting     return dist_mod In\u00a0[2]: Copied! <pre># Add a new function that reads in the data (data files should be in a directory called data)\ndef read_data(model_name):\n    d = np.genfromtxt('data/'+model_name+'.txt',delimiter=',')\n    zs = d[:,0]\n    mu = d[:,1]\n    muerr=d[:,2]\n    return zs, mu, muerr\n\nzs, mu, muerr = read_data('Data0')\n\n# Plot it to see what it looks like, this is called a Hubble diagram\nplt.errorbar(zs,mu,yerr=muerr,fmt='.',elinewidth=0.7,markersize=4,alpha=0.5)\nplt.xlim(0,1.0)\nplt.xlabel('redshift')\nplt.ylabel('magnitude')\nplt.show()\n</pre> # Add a new function that reads in the data (data files should be in a directory called data) def read_data(model_name):     d = np.genfromtxt('data/'+model_name+'.txt',delimiter=',')     zs = d[:,0]     mu = d[:,1]     muerr=d[:,2]     return zs, mu, muerr  zs, mu, muerr = read_data('Data0')  # Plot it to see what it looks like, this is called a Hubble diagram plt.errorbar(zs,mu,yerr=muerr,fmt='.',elinewidth=0.7,markersize=4,alpha=0.5) plt.xlim(0,1.0) plt.xlabel('redshift') plt.ylabel('magnitude') plt.show()  In\u00a0[8]: Copied! <pre>mu_om00_ox00 = dist_mod(zs,om=0.0,ol=0.0)  # We're going to use this empty model as a benchmark to compare the others to\nmu_om10_ox00 = dist_mod(zs,om=1.0,ol=0.0)\nmu_om03_ox00 = dist_mod(zs,om=0.3,ol=0.0)\nmu_om03_ox07 = dist_mod(zs,om=0.3,ol=0.7)\n\n# Plot it to see what it looks like, this is called a Hubble diagram\nplt.errorbar(zs,mu,yerr=muerr,fmt='.',elinewidth=0.7,markersize=4,alpha=0.5)\nplt.plot(zs,mu_om00_ox00,':',color='black',label='(0.0, 0.0)')\nplt.plot(zs,mu_om10_ox00,'-.',color='red',label='(1.0, 0.0)')\nplt.plot(zs,mu_om03_ox00,'--',color='blue',label='(0.3, 0.0)')\nplt.plot(zs,mu_om03_ox07,'-',color='green',label='(0.3, 0.7)')\nplt.xlim(0,1.0)\nplt.xlabel('redshift')\nplt.ylabel('magnitude')\nplt.legend(frameon=False)\nplt.show()\n\n# Now plot a Hubble diagram relative to the empty model (i.e. subtract the empty model from all the data and models)\nplt.errorbar(zs,mu-mu_om00_ox00,yerr=muerr,fmt='.',elinewidth=0.7,markersize=4,alpha=0.5)\nplt.plot(zs,mu_om10_ox00-mu_om00_ox00,'-.',color='red',label='(1.0, 0.0)')\nplt.plot(zs,mu_om03_ox00-mu_om00_ox00,'--',color='blue',label='(0.3, 0.0)')\nplt.plot(zs,mu_om03_ox07-mu_om00_ox00,'-',color='green',label='(0.3, 0.7)')\nplt.axhline(y=0.0,ls=':',color='black')\nplt.xlim(0.0,1.0)\nplt.xlabel('redshift')\nplt.ylabel('magnitude normalised to (0,0)')\nplt.legend(frameon=False)\nplt.show()\n</pre> mu_om00_ox00 = dist_mod(zs,om=0.0,ol=0.0)  # We're going to use this empty model as a benchmark to compare the others to mu_om10_ox00 = dist_mod(zs,om=1.0,ol=0.0) mu_om03_ox00 = dist_mod(zs,om=0.3,ol=0.0) mu_om03_ox07 = dist_mod(zs,om=0.3,ol=0.7)  # Plot it to see what it looks like, this is called a Hubble diagram plt.errorbar(zs,mu,yerr=muerr,fmt='.',elinewidth=0.7,markersize=4,alpha=0.5) plt.plot(zs,mu_om00_ox00,':',color='black',label='(0.0, 0.0)') plt.plot(zs,mu_om10_ox00,'-.',color='red',label='(1.0, 0.0)') plt.plot(zs,mu_om03_ox00,'--',color='blue',label='(0.3, 0.0)') plt.plot(zs,mu_om03_ox07,'-',color='green',label='(0.3, 0.7)') plt.xlim(0,1.0) plt.xlabel('redshift') plt.ylabel('magnitude') plt.legend(frameon=False) plt.show()  # Now plot a Hubble diagram relative to the empty model (i.e. subtract the empty model from all the data and models) plt.errorbar(zs,mu-mu_om00_ox00,yerr=muerr,fmt='.',elinewidth=0.7,markersize=4,alpha=0.5) plt.plot(zs,mu_om10_ox00-mu_om00_ox00,'-.',color='red',label='(1.0, 0.0)') plt.plot(zs,mu_om03_ox00-mu_om00_ox00,'--',color='blue',label='(0.3, 0.0)') plt.plot(zs,mu_om03_ox07-mu_om00_ox00,'-',color='green',label='(0.3, 0.7)') plt.axhline(y=0.0,ls=':',color='black') plt.xlim(0.0,1.0) plt.xlabel('redshift') plt.ylabel('magnitude normalised to (0,0)') plt.legend(frameon=False) plt.show() In\u00a0[227]: Copied! <pre># Calculate mscript for each of these, which is the thing that determines the vertical normalisation \nmscr_om10_ox00 = np.sum((mu_om10_ox00-mu)/muerr**2)/np.sum(1./muerr**2)\nmscr_om03_ox00 = np.sum((mu_om03_ox00-mu)/muerr**2)/np.sum(1./muerr**2)\nmscr_om03_ox07 = np.sum((mu_om03_ox07-mu)/muerr**2)/np.sum(1./muerr**2)\n\nprint(mscr_om10_ox00,mscr_om03_ox00,mscr_om03_ox07)\n\nmu_om10_ox00=mu_om10_ox00-mscr_om10_ox00\nmu_om03_ox00=mu_om03_ox00-mscr_om03_ox00\nmu_om03_ox07=mu_om03_ox07-mscr_om03_ox07\n\n# Repeat the plot and see how it changes\n# Plot it to see what it looks like, this is called a Hubble diagram\nplt.errorbar(zs,mu,yerr=muerr,fmt='.',elinewidth=0.7,markersize=4,alpha=0.5)\nplt.plot(zs,mu_om10_ox00,'-.',color='red',label='(1.0, 0.0)')\nplt.plot(zs,mu_om03_ox00,'--',color='blue',label='(0.3, 0.0)')\nplt.plot(zs,mu_om03_ox07,'-',color='green',label='(0.3, 0.7)')\nplt.xlim(0,1.0)\nplt.xlabel('redshift')\nplt.ylabel('magnitude')\nplt.legend(frameon=False)\nplt.show()\n\n# Now plot a Hubble diagram relative to the empty model (i.e. subtract the empty model from all the data and models)\nplt.errorbar(zs,mu-mu_om00_ox00,yerr=muerr,fmt='.',elinewidth=0.7,markersize=4,alpha=0.5)\nplt.plot(zs,mu_om10_ox00-mu_om00_ox00,'-.',color='red',label='(1.0, 0.0)')\nplt.plot(zs,mu_om03_ox00-mu_om00_ox00,'--',color='blue',label='(0.3, 0.0)')\nplt.plot(zs,mu_om03_ox07-mu_om00_ox00,'-',color='green',label='(0.3, 0.7)')\nplt.axhline(y=0.0,ls=':',color='black')\nplt.xlim(0,1.0)\nplt.xlabel('redshift')\nplt.ylabel('magnitude normalised to (0,0)')\nplt.legend(frameon=False)\nplt.show()\n</pre> # Calculate mscript for each of these, which is the thing that determines the vertical normalisation  mscr_om10_ox00 = np.sum((mu_om10_ox00-mu)/muerr**2)/np.sum(1./muerr**2) mscr_om03_ox00 = np.sum((mu_om03_ox00-mu)/muerr**2)/np.sum(1./muerr**2) mscr_om03_ox07 = np.sum((mu_om03_ox07-mu)/muerr**2)/np.sum(1./muerr**2)  print(mscr_om10_ox00,mscr_om03_ox00,mscr_om03_ox07)  mu_om10_ox00=mu_om10_ox00-mscr_om10_ox00 mu_om03_ox00=mu_om03_ox00-mscr_om03_ox00 mu_om03_ox07=mu_om03_ox07-mscr_om03_ox07  # Repeat the plot and see how it changes # Plot it to see what it looks like, this is called a Hubble diagram plt.errorbar(zs,mu,yerr=muerr,fmt='.',elinewidth=0.7,markersize=4,alpha=0.5) plt.plot(zs,mu_om10_ox00,'-.',color='red',label='(1.0, 0.0)') plt.plot(zs,mu_om03_ox00,'--',color='blue',label='(0.3, 0.0)') plt.plot(zs,mu_om03_ox07,'-',color='green',label='(0.3, 0.7)') plt.xlim(0,1.0) plt.xlabel('redshift') plt.ylabel('magnitude') plt.legend(frameon=False) plt.show()  # Now plot a Hubble diagram relative to the empty model (i.e. subtract the empty model from all the data and models) plt.errorbar(zs,mu-mu_om00_ox00,yerr=muerr,fmt='.',elinewidth=0.7,markersize=4,alpha=0.5) plt.plot(zs,mu_om10_ox00-mu_om00_ox00,'-.',color='red',label='(1.0, 0.0)') plt.plot(zs,mu_om03_ox00-mu_om00_ox00,'--',color='blue',label='(0.3, 0.0)') plt.plot(zs,mu_om03_ox07-mu_om00_ox00,'-',color='green',label='(0.3, 0.7)') plt.axhline(y=0.0,ls=':',color='black') plt.xlim(0,1.0) plt.xlabel('redshift') plt.ylabel('magnitude normalised to (0,0)') plt.legend(frameon=False) plt.show() <pre>0.25770106214612665 0.33200900865994 0.25770106214612665\n</pre> In\u00a0[4]: Copied! <pre># Set up the arrays for the models you want to test, e.g. a range of Omega_m and Omega_Lambda models:\nn = 21                          # Increase this for a finer grid\noms = np.linspace(0.0, 0.5, n)   # Array of matter densities\nols = np.linspace(0.0, 1.0, n)   # Array of cosmological constant values\nchi2 = np.ones((n, n)) * np.inf  # Array to hold our chi2 values, set initially to super large values\n\n# Calculate Chi2 for each model\nfor i, om in enumerate(oms):                                          # loop through matter densities\n        for j, ol in enumerate(ols):                                  # loop through cosmological constant densities\n            mu_model = dist_mod(zs, om=om, ol=ol)                     # calculate the distance modulus vs redshift for that model \n            mscr = np.sum((mu_model-mu)/muerr**2)/np.sum(1./muerr**2) # Calculate the vertical offset to apply\n            mu_model_norm = mu_model-mscr                             # Apply the vertical offset\n            chi2[i,j] = np.sum((mu_model_norm - mu) ** 2 / muerr**2)  # Calculate the chi2 and save it in a matrix\n            \n# Convert that to a likelihood and calculate the reduced chi2\nlikelihood = np.exp(-0.5 * (chi2-np.amin(chi2)))  # convert the chi^2 to a likelihood (np.amin(chi2) calculates the minimum of the chi^2 array)\nchi2_reduced = chi2 / (len(mu)-2)                 # calculate the reduced chi^2, i.e. chi^2 per degree of freedom, where dof = number of data points minus number of parameters being fitted \n\n# Calculate the best fit values (where chi2 is minimum)\nindbest = np.argmin(chi2)                 # Gives index of best fit but where the indices are just a single number\nibest   = np.unravel_index(indbest,[n,n]) # Converts the best fit index to the 2d version (i,j)\nprint( 'Best fit values are (om,ol)=(%.3f,%.3f)'%( oms[ibest[0]], ols[ibest[1]] ) )\nprint( 'Reduced chi^2 for the best fit is %0.2f'%chi2_reduced[ibest[0],ibest[1]] )\n</pre> # Set up the arrays for the models you want to test, e.g. a range of Omega_m and Omega_Lambda models: n = 21                          # Increase this for a finer grid oms = np.linspace(0.0, 0.5, n)   # Array of matter densities ols = np.linspace(0.0, 1.0, n)   # Array of cosmological constant values chi2 = np.ones((n, n)) * np.inf  # Array to hold our chi2 values, set initially to super large values  # Calculate Chi2 for each model for i, om in enumerate(oms):                                          # loop through matter densities         for j, ol in enumerate(ols):                                  # loop through cosmological constant densities             mu_model = dist_mod(zs, om=om, ol=ol)                     # calculate the distance modulus vs redshift for that model              mscr = np.sum((mu_model-mu)/muerr**2)/np.sum(1./muerr**2) # Calculate the vertical offset to apply             mu_model_norm = mu_model-mscr                             # Apply the vertical offset             chi2[i,j] = np.sum((mu_model_norm - mu) ** 2 / muerr**2)  # Calculate the chi2 and save it in a matrix              # Convert that to a likelihood and calculate the reduced chi2 likelihood = np.exp(-0.5 * (chi2-np.amin(chi2)))  # convert the chi^2 to a likelihood (np.amin(chi2) calculates the minimum of the chi^2 array) chi2_reduced = chi2 / (len(mu)-2)                 # calculate the reduced chi^2, i.e. chi^2 per degree of freedom, where dof = number of data points minus number of parameters being fitted   # Calculate the best fit values (where chi2 is minimum) indbest = np.argmin(chi2)                 # Gives index of best fit but where the indices are just a single number ibest   = np.unravel_index(indbest,[n,n]) # Converts the best fit index to the 2d version (i,j) print( 'Best fit values are (om,ol)=(%.3f,%.3f)'%( oms[ibest[0]], ols[ibest[1]] ) ) print( 'Reduced chi^2 for the best fit is %0.2f'%chi2_reduced[ibest[0],ibest[1]] ) <pre>Best fit values are (om,ol)=(0.500,1.000)\nReduced chi^2 for the best fit is 2.98\n</pre> In\u00a0[6]: Copied! <pre># Plot contours of 1, 2, and 3 sigma\nplt.contour(oms,ols,np.transpose(chi2-np.amin(chi2)),cmap=\"winter\",**{'levels':[2.30,6.18,11.83]})\nplt.plot(oms[ibest[0]], ols[ibest[1]],'x',color='black',label='(om,ol)=(%.3f,%.3f)'%( oms[ibest[0]], ols[ibest[1]]) )\nplt.xlabel(\"$\\Omega_m$\", fontsize=12)\nplt.ylabel(\"$\\Omega_\\Lambda$\", fontsize=12)\nplt.plot([oms[0],oms[1]], [ols[0],ols[1]],'-',color='black',label='Step size indicator' ) # Delete this line after making step size smaller!\nplt.legend(frameon=False)\n#plt.savefig('plots/contours.png', bbox_inches=\"tight\", transparent=True)\nplt.show()\nplt.close()\n</pre> # Plot contours of 1, 2, and 3 sigma plt.contour(oms,ols,np.transpose(chi2-np.amin(chi2)),cmap=\"winter\",**{'levels':[2.30,6.18,11.83]}) plt.plot(oms[ibest[0]], ols[ibest[1]],'x',color='black',label='(om,ol)=(%.3f,%.3f)'%( oms[ibest[0]], ols[ibest[1]]) ) plt.xlabel(\"$\\Omega_m$\", fontsize=12) plt.ylabel(\"$\\Omega_\\Lambda$\", fontsize=12) plt.plot([oms[0],oms[1]], [ols[0],ols[1]],'-',color='black',label='Step size indicator' ) # Delete this line after making step size smaller! plt.legend(frameon=False) #plt.savefig('plots/contours.png', bbox_inches=\"tight\", transparent=True) plt.show() plt.close()  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/Fit_Models/#3-fitting-models-to-data","title":"3. Fitting models to data\u00b6","text":"<p>In this workbook we will import data and find the cosmological model that best fits that data.</p>"},{"location":"notebooks/Fit_Models/#31-first-set-up-the-packages-and-functions","title":"3.1 First set up the packages and functions\u00b6","text":"<p>We need to know the distance modulus as a function of redshift.  Distance modulus is defined as  \\begin{equation} \\mu(z) = 5 \\log_{10}(D_L)\\end{equation} where \\begin{equation} D_L = R_0 S_k(\\chi) (1+z) \\end{equation} and $S_k(\\chi)=\\sin(\\chi), \\chi,\\; {\\rm or}\\; \\sinh(\\chi)$ for closed, flat, and open universes respectively, and \\begin{equation} R_0\\chi = \\frac{c}{H_0}\\int_0^z \\frac{dz}{E(z)}\\end{equation} with $E(z)=H(z)/H_0$.</p> <p>Note that the absolute magnitude of the SNe is about -19.5, but it enters as an additive constant in the same way as $c/H_0$ and both have high uncertainty.  Therefore we marginalise over this offset and it doesn't matter what value of $H_0$ we use.</p>"},{"location":"notebooks/Fit_Models/#important-in-the-code-below-replace-ez-10-with-the-actual-function-for-ez","title":"Important: In the code below, replace ez = 1.0 with the actual function for E(z).\u00b6","text":""},{"location":"notebooks/Fit_Models/#32-now-read-in-the-data","title":"3.2 Now read in the data\u00b6","text":"<p>I have generated some mock supernova data at random redshifts between $0.02&lt;z&lt;1.0$.  I then choose a cosmological model and calculate the distance modulus for each redshift in that model.  Then I give some uncertainty to the data points and scatter them randomly about the correct model by an amount corresponding to their uncertainty.</p> <p>I've generated 5 different models, all in files called DataX.txt, where X is a number from 0-4.</p> <p>There are five possible variables that I have specified in the models.  These are</p> <ul> <li>Matter density: $\\Omega_M$</li> <li>Dark Energy density: $\\Omega_\\Lambda$</li> <li>Radiation density: $\\Omega_R$</li> <li>Equation of state of dark energy: $w_0$</li> <li>Change in the equation of state with scalefactor: $w_a$, where $w=w_0+w_a(1-a)$.</li> </ul> <p>You can test your code on Data00.txt and Data0.txt.  Both were generated using a model with $(\\Omega_M,\\Omega_{\\Lambda})=(0.3,0.7)$ and all other parameters set to their standard values, namely $\\Omega_R=0.0$, $w_0=-1.0$, $w_a=0.0$.  In addition Data00.txt has perfect data with no scatter and small uncertainties, so you should be able to recover exactly the correct model.</p> <p>Data sets 1-2 are models in which $\\Omega_R=0.0$, $w_0=-1.0$, $w_a=0.0$ and only $\\Omega_M$ and $\\Omega_{\\Lambda}$ change.</p> <p>Data sets 3-4 could be anything! (Within the realms of the five parameters described above.)</p> <p>Feel free to choose which data set you want to analyse for your project.</p>"},{"location":"notebooks/Fit_Models/#33-calculate-the-theory-corresponding-to-that-data-for-a-range-of-cosmological-models","title":"3.3 Calculate the theory corresponding to that data for a range of cosmological models\u00b6","text":"<p>Then overplot them on the Hubble diagram.  Here we're just testing some specific interesting examples. It's always important to visualise your data and check that the models and data are doing what you think they are!</p>"},{"location":"notebooks/Fit_Models/#34-normalise-the-theory","title":"3.4 Normalise the theory\u00b6","text":"<p>You can see that there is a vertical offset between the different theory curves. We marginalise over this vertical offset, because we do not have enough information to constrain the vertical offset independently. In other words we use the data to determine what the vertical offset should be, but we do not care about what the answer is! (We are interested in the other parameters in the fit, but not that one.  The other parameters determine the shape of the curve.)</p> <p>The easiest way to normalise the curves is to take a weighted average of the difference between the data points and the theory in each case.</p>"},{"location":"notebooks/Fit_Models/#35-perform-a-fit-to-many-models","title":"3.5 Perform a fit to many models\u00b6","text":"<p>To find the best model that best matches the data use a $\\chi^2$ test.</p>"},{"location":"notebooks/Make_Mock_Data/","title":"4: Generating mock data","text":"In\u00a0[8]: Copied! <pre># First let's set up our packages\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom scipy import integrate\nfrom numpy.random import default_rng as rand\n\n# And set some constants\nc = 299792.458 # km/s (speed of light)\nH0kmsmpc = 70.  # Hubble constant in km/s/Mpc\n</pre> # First let's set up our packages import numpy as np from matplotlib import pyplot as plt from scipy import integrate from numpy.random import default_rng as rand  # And set some constants c = 299792.458 # km/s (speed of light) H0kmsmpc = 70.  # Hubble constant in km/s/Mpc In\u00a0[178]: Copied! <pre># Write a function for the integrand, i.e. $1/E(z)$,\ndef ezinv(z,om=0.3,ox=0.7,w0=-1.0,wa=0.0,orr=0.0):\n    ok = 1.-om-ox-orr\n    ### CODE HERE HIDDEN ###\n    return 1./ez\n\ndef Sk(xx, ok):\n    if ok &lt; 0.0:\n        dk = np.sin(np.sqrt(-ok)*xx)/np.sqrt(-ok)\n    elif ok &gt; 0.0:\n        dk = np.sinh(np.sqrt(ok)*xx)/np.sqrt(ok)\n    else:\n        dk = xx\n    return dk\n\ndef dist_mod(zs,om=0.3,ox=0.7,w0=-1.0,wa=0.0,orr=0.0):\n\"\"\" Calculate the distance modulus, correcting for curvature\"\"\"\n    ok = 1.0 - om - ox\n    xx = np.array([integrate.quad(ezinv, 0, z, args=(om, ox, w0, wa, orr))[0] for z in zs])\n    D = Sk(xx, ok)\n    lum_dist = D * (1 + zs) \n    dist_mod = 5 * np.log10(lum_dist) # Distance modulus\n    # Add an arbitrary constant that's approximately the log of c on Hubble constant minus absolute magnitude of -19.5\n    dist_mod = dist_mod + np.log(c/H0kmsmpc)-(-19.5)  # You can actually skip this step and it won't make a difference to our fitting\n    return dist_mod\n</pre> # Write a function for the integrand, i.e. $1/E(z)$, def ezinv(z,om=0.3,ox=0.7,w0=-1.0,wa=0.0,orr=0.0):     ok = 1.-om-ox-orr     ### CODE HERE HIDDEN ###     return 1./ez  def Sk(xx, ok):     if ok &lt; 0.0:         dk = np.sin(np.sqrt(-ok)*xx)/np.sqrt(-ok)     elif ok &gt; 0.0:         dk = np.sinh(np.sqrt(ok)*xx)/np.sqrt(ok)     else:         dk = xx     return dk  def dist_mod(zs,om=0.3,ox=0.7,w0=-1.0,wa=0.0,orr=0.0):     \"\"\" Calculate the distance modulus, correcting for curvature\"\"\"     ok = 1.0 - om - ox     xx = np.array([integrate.quad(ezinv, 0, z, args=(om, ox, w0, wa, orr))[0] for z in zs])     D = Sk(xx, ok)     lum_dist = D * (1 + zs)      dist_mod = 5 * np.log10(lum_dist) # Distance modulus     # Add an arbitrary constant that's approximately the log of c on Hubble constant minus absolute magnitude of -19.5     dist_mod = dist_mod + np.log(c/H0kmsmpc)-(-19.5)  # You can actually skip this step and it won't make a difference to our fitting     return dist_mod In\u00a0[198]: Copied! <pre>### Define the cosmological model!  (This will change for each data set you want to generate.)\n\nom=0.3  # Matter density\nox=0.7  # Dark Energy density\norr=0.0 # Radiation density\nw0=-1.0 # Dark Energy equation of state\nwa=-0.0  # Linear change with scalefactor of dark energy equation of state\n\nmodel_name='Data0'\n</pre> ### Define the cosmological model!  (This will change for each data set you want to generate.)  om=0.3  # Matter density ox=0.7  # Dark Energy density orr=0.0 # Radiation density w0=-1.0 # Dark Energy equation of state wa=-0.0  # Linear change with scalefactor of dark energy equation of state  model_name='Data0' In\u00a0[199]: Copied! <pre># Generate some random redshifts between 0.02 &lt; z &lt; 1.0.\nrng = np.random.default_rng(seed=3080) # initiate random number generator\nzs = rng.random(200) # Make 100 random numbers between 0 and 1\nzs = np.sort(zs) # Sort them in ascending order (just for simplicity)\nzs = zs[np.where(zs &gt; 0.02)] # Reject very low-redshifts. \n\n# Generate the corresponding distance moduli \nmuperfect = dist_mod(zs, om=om, ox=ox, w0=w0, wa=wa, orr=orr)\n\n# Add error bars (they'll all be around muerr of 0.1, but with a scatter of about 0.05)\nmuerr = 0.08+(rng.random(len(zs))-0.5)*0.05\n\n# Add scatter according to the size of the error bars\nmuscatter = rng.standard_normal(len(zs))*muerr\nmu = muperfect+muscatter\n\n# Plot as a sanity check\nplt.errorbar(zs,mu,yerr=muerr,fmt='.')\nplt.show()\n</pre> # Generate some random redshifts between 0.02 &lt; z &lt; 1.0. rng = np.random.default_rng(seed=3080) # initiate random number generator zs = rng.random(200) # Make 100 random numbers between 0 and 1 zs = np.sort(zs) # Sort them in ascending order (just for simplicity) zs = zs[np.where(zs &gt; 0.02)] # Reject very low-redshifts.   # Generate the corresponding distance moduli  muperfect = dist_mod(zs, om=om, ox=ox, w0=w0, wa=wa, orr=orr)  # Add error bars (they'll all be around muerr of 0.1, but with a scatter of about 0.05) muerr = 0.08+(rng.random(len(zs))-0.5)*0.05  # Add scatter according to the size of the error bars muscatter = rng.standard_normal(len(zs))*muerr mu = muperfect+muscatter  # Plot as a sanity check plt.errorbar(zs,mu,yerr=muerr,fmt='.') plt.show() <pre>0.06945931006937488\n</pre> In\u00a0[200]: Copied! <pre>data = np.zeros((len(zs),3)) # Set up an array with a row for each data point and 3 columns\ndata[:,0]=zs\ndata[:,1]=mu\ndata[:,2]=muerr\n\nnp.savetxt('data/'+model_name+'.txt', data, delimiter=',', fmt='%.6f, %.4f, %.4f', newline='\\n', header=model_name+'\\nzs, mu, muerr', comments='# ')\n\nwith open('data/'+model_name+'_solutions.txt', 'w') as f:\n    f.write('Solutions for '+model_name+':\\n')\n    f.write('Omega M = %.2f\\n'%om)\n    f.write('Omega X = %.2f\\n'%ox)\n    f.write('Omega R = %.2f\\n'%orr)\n    f.write('w0 = %.2f\\n'%w0)\n    f.write('wa = %.2f'%wa)\n    f.close()\n</pre> data = np.zeros((len(zs),3)) # Set up an array with a row for each data point and 3 columns data[:,0]=zs data[:,1]=mu data[:,2]=muerr  np.savetxt('data/'+model_name+'.txt', data, delimiter=',', fmt='%.6f, %.4f, %.4f', newline='\\n', header=model_name+'\\nzs, mu, muerr', comments='# ')  with open('data/'+model_name+'_solutions.txt', 'w') as f:     f.write('Solutions for '+model_name+':\\n')     f.write('Omega M = %.2f\\n'%om)     f.write('Omega X = %.2f\\n'%ox)     f.write('Omega R = %.2f\\n'%orr)     f.write('w0 = %.2f\\n'%w0)     f.write('wa = %.2f'%wa)     f.close() In\u00a0[151]: Copied! <pre>def read_data(model_name):\n    d = np.genfromtxt(model_name+'.txt',delimiter=',')\n    zs = d[:,0]\n    mu = d[:,1]\n    muerr=d[:,2]\n    return zs, mu, muerr\n\nzs, mu, muerr = read_data(model_name)\n</pre> def read_data(model_name):     d = np.genfromtxt(model_name+'.txt',delimiter=',')     zs = d[:,0]     mu = d[:,1]     muerr=d[:,2]     return zs, mu, muerr  zs, mu, muerr = read_data(model_name)"},{"location":"notebooks/Make_Mock_Data/#4-generating-mock-data","title":"4: Generating mock data\u00b6","text":"<p>This notebook shows how the supernova data is generated.  You don't actually need to use this, it's just here to show you how it is done.</p>"},{"location":"notebooks/Make_Mock_Data/#41-first-set-the-constants-and-load-packages","title":"4.1. First set the constants and load packages.\u00b6","text":""},{"location":"notebooks/Make_Mock_Data/#42-then-write-the-functions-well-need","title":"4.2. Then write the functions we'll need.\u00b6","text":"<p>We need to know the distance modulus as a function of redshift.  Distance modulus is defined as  \\begin{equation} \\mu(z) = 5 \\log_{10}(D_L)\\end{equation} where \\begin{equation} D_L = R_0 S_k(\\chi) (1+z) \\end{equation} and $S_k(\\chi)=\\sin(\\chi), \\chi,\\; {\\rm or}\\; \\sinh(\\chi)$ for closed, flat, and open universes respectively, and \\begin{equation} \\chi = \\frac{c}{R_0H_0}\\int_0^z \\frac{dz}{E(z)}\\end{equation} with $E(z)=H(z)/H_0$.</p>"},{"location":"notebooks/Make_Mock_Data/#43-now-generate-some-perfect-data-according-to-the-theory","title":"4.3. Now generate some perfect data according to the theory.\u00b6","text":""},{"location":"notebooks/Make_Mock_Data/#44-print-file-with-data-and-separate-file-saving-the-inputs","title":"4.4 Print file with data AND separate file saving the inputs\u00b6","text":""},{"location":"notebooks/Make_Mock_Data/#45-this-is-a-function-that-will-read-in-that-data","title":"4.5 This is a function that will read in that data\u00b6","text":""}]}